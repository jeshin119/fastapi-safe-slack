<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>워크스페이스 - WorkSpace</title>
    
    <!-- CSS 파일들 임포트 -->
    <link rel="stylesheet" href="/static/css/common.css">
    <link rel="stylesheet" href="/static/css/workspace-main.css">
</head>
<body>
    <!-- 파일 입력 (숨김) -->
    <input type="file" id="file-input" multiple accept="*/*">

    <!-- 사이드바 -->
    <div class="sidebar">
        <div class="workspace-header">
            <div class="workspace-name" id="workspace-name">🌊 로딩중...</div>
            <div class="workspace-info" id="workspace-info">팀 협업 공간</div>
        </div>
        
        <div class="channels-section">
            <div class="section-header">
                <div class="section-title">채널</div>
                <button class="refresh-btn" onclick="refreshChannels()" title="채널 새로고침">🔄</button>
            </div>
            
            <!-- 채널 목록에 스크롤 컨테이너 추가 -->
            <div class="channel-list-container">
                <ul class="channel-list" id="channel-list">
                    <!-- 채널들이 여기에 동적으로 추가됩니다 -->
                </ul>
            </div>
            
            <div class="add-channel-button">
                <button class="add-channel-btn" onclick="location.href='channel-add.html'">
                    ➕ 채널 추가
                </button>
            </div>
        </div>

        <div class="user-section">
            <div class="section-title">팀원</div>
            <!-- 팀원 목록에 스크롤 컨테이너 추가 -->
            <div class="team-members-container">
                <div id="team-members-list">
                    <!-- 팀원 목록이 여기에 동적으로 추가됩니다 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 메인 콘텐츠 -->
    <div class="main-content">
        <header class="chat-header">
            <div class="header-left">
                <h1 id="current-channel-title"># 로딩중...</h1>
                <p id="current-channel-description">채널 정보를 가져오는 중...</p>
            </div>
            <div class="header-right">
                <span class="channel-badge public" id="channel-type-badge">🌍 공개</span>
                <button class="admin-btn" id="workspace-admin-btn" onclick="goToAdminPage()" title="관리자 페이지" style="display: none;">👑 관리자</button>
            </div>
        </header>

        <!-- 탭 네비게이션 -->
        <nav class="content-tabs">
            <button class="tab-button active" data-tab="chat" onclick="switchTab('chat')">
                💬 대화
                <span class="tab-count" id="message-count">0</span>
            </button>
            <button class="tab-button" data-tab="files" onclick="switchTab('files')">
                📁 파일
                <span class="tab-count" id="file-count">0</span>
            </button>
        </nav>

        <!-- 채팅 탭 (기본) -->
        <div class="tab-content active" id="chat-content">
            <div class="chat-content">
                <div class="welcome-section" id="welcome-message">
                    <div class="welcome-icon">🏠</div>
                    <div class="welcome-title">채널에 오신 것을 환영합니다</div>
                    <div class="welcome-description">
                        자유롭게 소통하고 파일을 공유하세요. ⭐
                    </div>
                </div>

                <!-- 채팅 메시지에 스크롤 컨테이너 추가 -->
                <div class="chat-messages-container">
                    <div class="chat-messages" id="chat-messages">
                        <!-- 메시지들이 여기에 동적으로 표시됩니다 -->
                    </div>
                </div>

                <div class="message-input-container">
                    <textarea class="message-input" id="message-input" placeholder="메시지를 입력하세요..." rows="1"></textarea>
                    <div class="input-toolbar">
                        <div class="input-actions">
                            <button class="input-btn" onclick="attachFile()" title="파일 첨부">📎</button>
                            <button class="input-btn" onclick="addEmoji()" title="이모지">😊</button>
                            <button class="input-btn" onclick="mentionUser()" title="멘션">@</button>
                            <button class="input-btn" onclick="voiceMessage()" title="음성 메시지">🎤</button>
                        </div>
                        <button class="send-btn" id="send-btn" onclick="sendMessage()">전송</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 파일 탭 -->
        <div class="tab-content" id="files-content">
            <div class="files-content">
                <div class="upload-area" id="upload-area" onclick="triggerFileUpload()">
                    <div class="upload-icon">📁</div>
                    <div class="upload-title">파일 업로드</div>
                    <div class="upload-description">
                        파일을 드래그하여 놓거나 클릭하여 선택하세요
                    </div>
                    <button class="upload-button">📤 파일 선택</button>
                </div>

                <!-- 파일 업로드 옵션 (숨김) -->
                <div class="upload-options" id="upload-options" style="display: none;">
                    <div class="options-title">📋 파일 접근 권한 설정</div>
                    
                    <div class="form-group">
                        <label class="form-label" for="min-role">최소 접근 직급 (선택)</label>
                        <select class="form-select" id="min-role">
                            <option value="">모든 직급</option>
                            <!-- 역할 목록이 여기에 동적으로 추가됩니다 -->
                        </select>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label class="form-label" for="valid-from">접근 시작일 (선택)</label>
                            <input type="date" class="form-input" id="valid-from">
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="valid-to">접근 종료일 (선택)</label>
                            <input type="date" class="form-input" id="valid-to">
                        </div>
                    </div>



                    <button class="upload-button" id="upload-submit-btn" style="width: 100%; margin-top: 16px;">📤 선택된 파일 업로드</button>
                </div>

                <!-- 파일 목록에 스크롤 컨테이너 추가 -->
                <div class="files-list-container">
                    <div id="files-list">
                        <!-- 파일 목록이 여기에 동적으로 추가됩니다 -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 로딩 오버레이 -->
    <div id="loading-overlay" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-icon">⏳</div>
            <h3 class="modal-title">워크스페이스 로딩 중...</h3>
            <p class="modal-description">데이터를 불러오고 있습니다.</p>
        </div>
    </div>

    <!-- 새 채널 환영 모달 -->
    <div id="new-channel-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-icon">🎉</div>
            <h3 class="modal-title">새 채널이 생성되었습니다!</h3>
            <p class="modal-description" id="new-channel-message">채널이 성공적으로 추가되었습니다.</p>
            <button class="modal-button" onclick="closeNewChannelModal()">확인</button>
        </div>
    </div>

    <script src="../../js/config.js"></script>
    <script src="../../js/alert-system.js"></script>
    <script>
        // 서버 연결 설정
        // API_BASE_URL은 config.js에서 자동으로 설정됨
        const WEBSOCKET_BASE_URL = 'wss://localhost:8000/ws';
    
        // 전역 데이터 저장소
        let globalData = {
            user: null,
            workspace: null,
            channels: [],
            currentChannel: null,
            messages: {},  
            files: {},     
            teamMembers: [],
            isLoadingOlderMessages: false
        };
        
        let currentChannelName = null;
        let currentTab = 'chat';
        let websocket = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
    
        // API 호출 함수
        async function apiCall(endpoint, options = {}) {
            try {
                const token = localStorage.getItem('jwt_token') || localStorage.getItem('access_token');
                const defaultHeaders = {
                    'Content-Type': 'application/json'
                };
    
                if (token) {
                    defaultHeaders['Authorization'] = `Bearer ${token}`;
                }
    
                const response = await fetch(`${API_BASE_URL}${endpoint}`, {
                    headers: {
                        ...defaultHeaders,
                        ...options.headers
                    },
                    ...options
                });
    
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    
                    // 인증 오류 처리
                    if (response.status === 401 || response.status === 403) {
                        handleAuthError();
                        return;
                    }
                    
                    throw new Error(errorData.detail || `HTTP ${response.status}: ${response.statusText}`);
                }
    
                return await response.json();
            } catch (error) {
                console.error(`API 호출 오류 (${endpoint}):`, error);
                
                // 네트워크 오류 시 연결 상태 업데이트
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    updateConnectionStatus('offline');
                }
                
                throw error;
            }
        }
    
        // 인증 오류 처리 함수
        function handleAuthError() {
            localStorage.removeItem('jwt_token');
            localStorage.removeItem('access_token');
            localStorage.removeItem('current_workspace_name');
            localStorage.removeItem('is_workspace_admin');
            showAlert('인증이 만료되었습니다. 다시 로그인해주세요.');
            window.location.href = '/login.html';
        }
    
        // WebSocket 연결 관리 (최적화)
        function connectWebSocket() {
            try {
                if (!currentChannelName || !globalData.workspace?.name) {
                    console.log('WebSocket 연결 대기: 채널이나 워크스페이스 정보가 없음');
                    return;
                }

                const token = localStorage.getItem('jwt_token') || localStorage.getItem('access_token');
                if (!token) {
                    console.error('WebSocket 연결을 위한 토큰이 없습니다.');
                    return;
                }

                // 이미 연결 중이거나 연결된 상태인지 확인 (개선된 체크)
                if (websocket) {
                    if (websocket.readyState === WebSocket.OPEN) {
                        console.log('✅ WebSocket이 이미 연결된 상태입니다.');
                        return;
                    }
                    if (websocket.readyState === WebSocket.CONNECTING) {
                        console.log('🔄 WebSocket이 이미 연결 중입니다.');
                        return;
                    }
                }

                // 기존 연결이 있으면 안전하게 닫기 (개선된 로직)
                if (websocket && websocket.readyState !== WebSocket.CLOSED) {
                    try {
                        websocket.close(1000, 'Channel switch');
                    } catch (e) {
                        console.log('기존 WebSocket 연결 닫기 실패:', e);
                    }
                    websocket = null;
                }

                // 잠시 대기 후 새 연결 시도 (지연 시간 단축)
                setTimeout(() => {
                    const wsUrl = `${WEBSOCKET_BASE_URL}/${globalData.workspace.name}/${currentChannelName}?token=${token}`;
                    console.log('WebSocket 연결 시도:', wsUrl);
                    
                    websocket = new WebSocket(wsUrl);
                    
                    websocket.onopen = function() {
                        console.log('✅ WebSocket 연결됨:', currentChannelName);
                        updateConnectionStatus('online');
                        reconnectAttempts = 0;
                    };
        
                    websocket.onmessage = function(event) {
                        const data = JSON.parse(event.data);
                        console.log('📨 WebSocket 메시지 수신:', data);
                        handleWebSocketMessage(data);
                    };
        
                    websocket.onclose = function(event) {
                        console.log('❌ WebSocket 연결 종료:', event.code, event.reason);
                        updateConnectionStatus('offline');
                        
                        // 정상적인 종료가 아닌 경우에만 재연결 시도
                        if (event.code !== 1000) {
                            attemptReconnect();
                        }
                    };
        
                    websocket.onerror = function(error) {
                        console.error('❌ WebSocket 오류:', error);
                        updateConnectionStatus('offline');
                    };
                }, 200); // 200ms로 단축

            } catch (error) {
                console.error('WebSocket 연결 실패:', error);
                updateConnectionStatus('offline');
            }
        }
    
        function attemptReconnect() {
            // 재연결 조건 개선
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS && 
                currentChannelName && 
                (!websocket || websocket.readyState === WebSocket.CLOSED)) {
                
                reconnectAttempts++;
                updateConnectionStatus('reconnecting');
                setTimeout(() => {
                    console.log(`🔄 재연결 시도 ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}`);
                    connectWebSocket();
                }, 2000 * reconnectAttempts);
            }
        }
    
        function handleWebSocketMessage(data) {
            console.log('🔧 WebSocket 메시지 처리:', data.type, data);
            
            switch (data.type) {
                case 'connection':
                    console.log('✅ WebSocket 연결 확인:', data.message);
                    break;
                    
                case 'message':
                case 'new_message':
                    // 메시지 수신 처리
                    if (!globalData.messages[currentChannelName]) {
                        globalData.messages[currentChannelName] = [];
                    }
                    
                    const newMessage = {
                        id: data.message_id,
                        content: data.content,
                        user_id: data.user_id,
                        user_name: data.user_name,
                        user_email: data.user_email || data.user_name,
                        message_type: data.message_type || 'text',
                        timestamp: data.timestamp,
                        created_at: data.timestamp
                    };
                    
                    globalData.messages[currentChannelName].push(newMessage);
                    renderMessages();
                    updateChannelContent();
                    
                    // 새 메시지 수신 시 자동 스크롤 여부에 따라 스크롤 이동
                    setTimeout(() => {
                        const messagesContainer = document.getElementById('chat-messages');
                        if (messagesContainer && shouldAutoScroll) {
                            scrollToBottom(messagesContainer, 'smooth');
                        }
                    }, 100);
                    break;
                    
                case 'message_history':
                    // 메시지 히스토리 수신 처리
                    if (data.messages && data.messages.length > 0) {
                        // DynamoDB에서 이미 시간순으로 정렬되어 옴 (맨 위가 가장 예전 메시지)
                        globalData.messages[currentChannelName] = data.messages.map(msg => ({
                            id: msg.message_id,
                            content: msg.content,
                            user_id: msg.user_id,
                            user_name: msg.user_name,
                            user_email: msg.user_name, // DynamoDB에는 email이 없을 수 있음
                            message_type: msg.message_type || 'text',
                            timestamp: msg.timestamp,
                            created_at: msg.timestamp
                        }));
                        renderMessages();
                        updateChannelContent();
                        setupScrollHandler(); // 스크롤 핸들러 설정
                        
                        // 메시지 히스토리 로드 후 스크롤을 맨 아래로 이동
                        setTimeout(() => {
                            const messagesContainer = document.getElementById('chat-messages');
                            if (messagesContainer) {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                            }
                        }, 200);
                    }
                    break;
                    
                case 'older_messages':
                    // 더 이전 메시지 수신 처리
                    if (data.messages && data.messages.length > 0) {
                        const messages = globalData.messages[currentChannelName] || [];
                        
                        // 기존 메시지 앞에 새로운 메시지들 추가
                        const newMessages = data.messages.map(msg => ({
                            id: msg.message_id,
                            content: msg.content,
                            user_id: msg.user_id,
                            user_name: msg.user_name,
                            user_email: msg.user_name,
                            message_type: msg.message_type || 'text',
                            timestamp: msg.timestamp,
                            created_at: msg.timestamp
                        }));
                        
                        globalData.messages[currentChannelName] = [...newMessages, ...messages];
                        
                        // 로딩 표시 제거
                        const loadingDiv = document.querySelector('.loading-older-messages');
                        if (loadingDiv) {
                            loadingDiv.remove();
                        }
                        
                        // 로딩 상태 리셋
                        globalData.isLoadingOlderMessages = false;
                        
                        renderMessages();
                        updateChannelContent();
                    }
                    break;
                    
                case 'no_older_messages':
                    // 더 이상 이전 메시지가 없음
                    // const loadingDiv = document.querySelector('.loading-older-messages');
                    // if (loadingDiv) {
                    //     loadingDiv.innerHTML = '<span>더 이상 이전 메시지가 없습니다.</span>';
                    //     setTimeout(() => {
                    //         loadingDiv.remove();
                    //     }, 2000);
                    // }
                    // 로딩 상태 리셋
                    globalData.isLoadingOlderMessages = false;
                    break;
                    
                case 'user_joined':
                    console.log('👋 사용자 입장:', data.user_name);
                    break;
                    
                case 'user_left':
                    console.log('👋 사용자 퇴장:', data.user_name);
                    break;
                    
                case 'typing':
                    console.log('⌨️ 타이핑 상태:', data.user_name);
                    break;
                    
                // case 'connected_users':
                //     console.log('👥 연결된 사용자:', data.connected_users);
                //     break;
                    
                case 'error':
                    console.error('❌ WebSocket 에러:', data.message);
                    showAlert('채팅 오류: ' + data.message);
                    break;
                    
                default:
                    console.log('❓ 알 수 없는 메시지 타입:', data.type, data);
            }
        }
    
        // 이 함수를 추가해주세요
        function scrollToBottom(container, behavior = 'smooth') {
            if (!container) return;
            
            setTimeout(() => {
                container.scrollTo({
                    top: container.scrollHeight,
                    behavior: behavior
                });
            }, 50);
        }
                // 연결 상태 업데이트
        function updateConnectionStatus(status) {
            // 연결 상태 표시 요소가 있다면 업데이트
            const statusElement = document.getElementById('connection-status');
            const statusText = document.querySelector('.status-text');
            
            if (statusElement) {
                statusElement.className = `connection-status ${status}`;
            }
            
            if (statusText) {
                switch (status) {
                    case 'online':
                        statusText.textContent = '온라인';
                        break;
                    case 'offline':
                        statusText.textContent = '오프라인';
                        break;
                    case 'reconnecting':
                        statusText.textContent = '재연결 중...';
                        break;
                }
            }
        }
    
        // JWT 토큰에서 사용자 정보 추출
        function getUserInfoFromToken() {
            const token = localStorage.getItem('jwt_token') || localStorage.getItem('access_token');
            if (!token) {
                showAlert('로그인이 필요합니다.');
                window.location.href = '/login.html';
                return null;
            }
    
            try {
                // JWT 토큰 파싱
                const payload = JSON.parse(atob(token.split('.')[1]));
                
                // 토큰 만료 체크
                if (payload.exp && Date.now() >= payload.exp * 1000) {
                    console.error('토큰이 만료되었습니다.');
                    handleAuthError();
                    return null;
                }
    
                // 로컬스토리지의 워크스페이스 정보와 JWT 정보 결합
                const workspaceName = localStorage.getItem('current_workspace_name') || payload.workspace_name;
                const isAdmin = localStorage.getItem('is_workspace_admin') === 'true' || payload.is_workspace_admin;
    
                return {
                    user_id: payload.user_id,
                    user_email: payload.user_email,
                    user_name: payload.user_name,
                    workspace_id: payload.workspace_id,
                    workspace_name: workspaceName,
                    role_id: payload.role_id,
                    role_name: payload.role_name || '멤버',
                    is_workspace_admin: isAdmin,
                    is_contractor: payload.is_contractor || false
                };
            } catch (error) {
                console.error('토큰 파싱 실패:', error);
                handleAuthError();
                return null;
            }
        }
    
        // 초기 데이터 로딩
        async function initializeWorkspace() {
            try {
                document.getElementById('loading-overlay').style.display = 'flex';
                
                const userInfo = getUserInfoFromToken();
                if (!userInfo) return;
                
                globalData.user = userInfo;
                globalData.workspace = {
                    name: userInfo.workspace_name,
                    id: userInfo.workspace_id
                };
    
                // UI 업데이트
                document.getElementById('workspace-name').textContent = `🌊 ${userInfo.workspace_name}`;
                document.getElementById('workspace-info').textContent = `${userInfo.role_name} • ${userInfo.is_workspace_admin ? '관리자' : '멤버'}`;
    
                // 관리자인 경우만 워크스페이스 설정 버튼 표시
                if (userInfo.is_workspace_admin) {
                    document.getElementById('workspace-admin-btn').style.display = 'block';
                }
    
                // URL 파라미터 정리
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('from_select')) {
                    urlParams.delete('from_select');
                    const newUrl = urlParams.toString() ? 
                        `${window.location.pathname}?${urlParams.toString()}` : 
                        window.location.pathname;
                    window.history.replaceState({}, document.title, newUrl);
                }
    
                // 병렬로 데이터 로딩
                await Promise.all([
                    loadChannels(),
                    loadTeamMembers()
                ]);
                
                const defaultChannel = globalData.channels.find(ch => ch.is_default) || globalData.channels[0];
                if (defaultChannel) {
                    await switchChannel(defaultChannel.name);
                }
    
            } catch (error) {
                console.error('워크스페이스 초기화 실패:', error);
                showAlert('워크스페이스 로딩에 실패했습니다. 워크스페이스 선택 페이지로 돌아갑니다.');
                window.location.href = '/workspace-select.html';
            } finally {
                document.getElementById('loading-overlay').style.display = 'none';
            }
        }
    
        // 관리자 페이지 이동
        function goToAdminPage() {
            if (!globalData.user?.is_workspace_admin) {
                showAlert('관리자 권한이 필요합니다.');
                return;
            }
            
            window.location.href = `workspace-admin.html?workspace_name=${encodeURIComponent(globalData.workspace.name)}`;
        }
    
        // 채널 목록 로딩
        async function loadChannels() {
            try {
                const workspaceName = globalData.workspace?.name;
                if (!workspaceName) {
                    console.error('워크스페이스 이름이 없습니다.');
                    return;
                }

                // POST /channels/list로 변경
                const channels = await apiCall('/channels/list', {
                    method: 'POST',
                    body: JSON.stringify({
                        workspace_name: workspaceName
                    })
                });

                console.log('📋 채널 목록 응답:', channels);

                // 응답이 배열인지 객체인지 확인하고 처리
                let channelArray = [];
                if (Array.isArray(channels)) {
                    channelArray = channels;
                } else if (channels.channels && Array.isArray(channels.channels)) {
                    channelArray = channels.channels;
                } else {
                    console.error('예상하지 못한 응답 구조:', channels);
                    channelArray = [];
                }
                
                // 채널 데이터 변환
                globalData.channels = channelArray.map(channel => ({
                    id: channel.channel_id || channel.id,
                    name: channel.name || channel.channel_name,
                    is_public: channel.is_public !== false, // 기본값을 true로
                    is_default: channel.name === 'general' || channel.is_default
        }));

                console.log('✅ 변환된 채널 목록:', globalData.channels);
                
                renderChannelList();
            } catch (error) {
                console.error('채널 로딩 실패:', error);
            }
        }

         // 에러 발생 시 빈 배열로 설정하고 렌더링
        globalData.channels = [];
        renderChannelList();
        
        // 팀원 목록 로딩 (실제 워크스페이스 멤버 API 사용)
        async function loadTeamMembers() {
            try {
                const workspaceName = globalData.workspace?.name;
                
                if (!workspaceName) {
                    console.log('워크스페이스 정보 없음');
                    globalData.teamMembers = [];
                    renderTeamMembers();
                    return;
                }

                // POST /workspaces/members로 워크스페이스 멤버 조회
                const members = await apiCall('/workspaces/members', {
                    method: 'POST',
                    body: JSON.stringify({
                        workspace_name: workspaceName
                    })
                });
                
                // 응답 데이터 구조에 맞게 변환
                globalData.teamMembers = members.map(member => ({
                    user_id: member.user_id,
                    user_email: member.email,
                    user_name: member.name,
                    role_name: member.role_name,
                    is_admin: true 
                }));
                        
                renderTeamMembers();
            } catch (error) {
                console.error('팀원 로딩 실패:', error);
                globalData.teamMembers = [];
                renderTeamMembers();
            }
        }
    
        // 채널 목록 렌더링
        function renderChannelList() {
            const channelList = document.getElementById('channel-list');
            
            channelList.innerHTML = globalData.channels.map(channel => {
                const isActive = channel.name === currentChannelName ? 'active' : '';
                const visibilityIcon = channel.is_public ? '#' : '🔒';
                const messageCount = globalData.messages[channel.name]?.length || 0;
                
                return `
                    <li class="channel-item ${isActive}" data-channel-name="${channel.name}" onclick="switchChannel('${channel.name}')">
                        <span class="channel-icon">${visibilityIcon}</span>
                        <span class="channel-name">${channel.name}</span>
                        ${messageCount > 0 ? `<span class="message-count">${messageCount}</span>` : ''}
                    </li>
                `;
            }).join('');
        }
    
        // 팀원 목록 렌더링
        function renderTeamMembers() {
            const container = document.getElementById('team-members-list');
            const members = globalData.teamMembers || [];
            
            container.innerHTML = members.map(member => `
                <div class="team-member-item">
                    <div class="member-status ${member.is_online ? 'online' : 'offline'}"></div>
                    <span class="member-name">${member.user_email.split('@')[0]}</span>
                    <span class="member-role">${member.role_name}</span>
                </div>
            `).join('');
        }
    
        // 채널 새로고침
        async function refreshChannels() {
            await loadChannels();
            if (currentChannelName) {
                await loadChannelData(currentChannelName);
                updateChannelContent();
            }
        }
    
        // 팀원 새로고침
        async function refreshTeamMembers() {
            await loadTeamMembers();
        }
    
        // 채널 데이터 로딩
        async function loadChannelData(channelName) {
            try {
                // 메시지 초기화 (WebSocket으로 받을 예정)
                if (!globalData.messages[channelName]) {
                    globalData.messages[channelName] = [];
                }
                if (!globalData.files[channelName]) {
                    globalData.files[channelName] = [];
                }
                
                console.log(`📚 채널 ${channelName} 데이터 초기화`);
            } catch (error) {
                console.error('채널 데이터 로딩 실패:', error);
            }
        }
    
        // 채널 전환
        async function switchChannel(channelName) {
            try {
                // 이전 WebSocket 연결 안전하게 종료 (개선된 로직)
                if (websocket && websocket.readyState !== WebSocket.CLOSED) {
                    try {
                        websocket.close(1000, 'Channel switch');
                    } catch (e) {
                        console.log('기존 WebSocket 연결 닫기 실패:', e);
                    }
                    websocket = null;
                }
                
                currentChannelName = channelName;
                
                const channel = globalData.channels.find(ch => ch.name === channelName);
                if (!channel) return;
    
                globalData.currentChannel = channel;
                
                // 채널 데이터가 없으면 로딩
                if (!globalData.messages[channelName]) {
                    await loadChannelData(channelName);
                }
                
                renderChannelList();
                document.getElementById('current-channel-title').textContent = `# ${channel.name}`;
                document.getElementById('current-channel-description').textContent = 
                    channel.is_default ? '기본 채널입니다' : (channel.is_public ? '공개 채널입니다' : '비공개 채널입니다');
                
                const typeBadge = document.getElementById('channel-type-badge');
                if (channel.is_public) {
                    typeBadge.textContent = '🌍 공개';
                    typeBadge.className = 'channel-badge public';
                } else {
                    typeBadge.textContent = '🔒 비공개';
                    typeBadge.className = 'channel-badge private';
                }
                
                document.getElementById('message-input').placeholder = `# ${channel.name} 채널에 메시지 보내기`;
                updateChannelContent();

                // 새 채널로 WebSocket 연결 (지연 시간 단축)
                setTimeout(() => {
                    connectWebSocket();
                }, 300); // 300ms로 단축
    
            } catch (error) {
                console.error('채널 전환 실패:', error);
            }
        }
    
        function updateChannelContent() {
            const channel = globalData.currentChannel;
            if (!channel) return;
            
            const welcomeMessage = document.getElementById('welcome-message');
            welcomeMessage.innerHTML = `
                <div class="welcome-icon">🏠</div>
                <div class="welcome-title"># ${channel.name} 채널에 오신 것을 환영합니다</div>
                <div class="welcome-description">
                    ${channel.is_public ? '모든 멤버가 참여할 수 있는 공개 채널입니다.' : '초대받은 멤버만 참여할 수 있는 비공개 채널입니다.'} 자유롭게 소통하고 파일을 공유하세요. ⭐
                </div>
            `;
    
            const messages = globalData.messages[channel.name] || [];
            const files = globalData.files[channel.name] || [];
            
            document.getElementById('message-count').textContent = messages.length;
            document.getElementById('file-count').textContent = files.length;
    
            renderMessages();
            renderFiles();
        }
    
        // 탭 전환
        function switchTab(tabName) {
            currentTab = tabName;
            
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-content`).classList.add('active');
        }
    
        // 메시지 렌더링
        function renderMessages() {
            const messagesContainer = document.getElementById('chat-messages');
            const messages = globalData.messages[currentChannelName] || [];
            
            if (messages.length === 0) {
                messagesContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">💬</div>
                        <div class="empty-title">아직 메시지가 없습니다</div>
                        <div class="empty-description">첫 번째 메시지를 보내보세요!</div>
                    </div>
                `;
                return;

                setTimeout(() => {
                    const container = document.getElementById('chat-messages');
                    const parentHeight = container.parentElement.parentElement.offsetHeight;
                    container.parentElement.style.height = `${parentHeight - 200}px`; // 200px는 여백
                }, 50);
            }
            
            messagesContainer.innerHTML = messages.map(message => {
                const messageTime = new Date(message.timestamp || message.created_at).toLocaleTimeString('ko-KR', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                const userDisplayName = message.user_email || message.user_name || 'Unknown';
                const avatarLetter = userDisplayName.charAt(0).toUpperCase();
                
                return `
                    <div class="message">
                        <div class="message-avatar">${avatarLetter}</div>
                        <div class="message-content">
                            <div class="message-header">
                                <span class="message-author">${userDisplayName}</span>
                                <span class="message-time">${messageTime}</span>
                            </div>
                            <div class="message-text">${message.content.replace(/\n/g, '<br>')}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // 지연 시간 추가로 DOM 렌더링 완료 후 스크롤
            setTimeout(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }, 100);
                    }

        // 스크롤 이벤트 처리 (개선됨)
        let scrollHandlerInitialized = false;
        let scrollTimeout = null;
        let isUserScrolling = false; // 사용자가 스크롤 중인지 추적
        let shouldAutoScroll = true; // 자동 스크롤 여부
        
        function setupScrollHandler() {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer || scrollHandlerInitialized) return;
            
            // 스크롤 이벤트 리스너 한 번만 추가
            messagesContainer.addEventListener('scroll', handleScroll);
            scrollHandlerInitialized = true;
        }
        
        function handleScroll() {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;
            
            // 사용자가 스크롤 중인지 확인
            const scrollTop = messagesContainer.scrollTop;
            const scrollHeight = messagesContainer.scrollHeight;
            const clientHeight = messagesContainer.clientHeight;
            
            // 스크롤이 맨 아래에 가까운지 확인 (50px 이내)
            const isNearBottom = scrollHeight - scrollTop - clientHeight < 50;
            
            // 자동 스크롤 여부 업데이트
            shouldAutoScroll = isNearBottom;
            
            // 디바운싱으로 중복 요청 방지
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
            }
            
            scrollTimeout = setTimeout(() => {
                // 스크롤이 맨 위에 가까워지면 더 이전 메시지 요청
                if (scrollTop <= 100 && !globalData.isLoadingOlderMessages) {
                    const messages = globalData.messages[currentChannelName] || [];
                    if (messages.length > 0) {
                        const oldestMessage = messages[0];
                        if (oldestMessage && oldestMessage.timestamp) {
                            globalData.isLoadingOlderMessages = true;
                            
                            // 로딩 표시 (메시지 없이 스피너만)
                            const loadingDiv = document.createElement('div');
                            loadingDiv.className = 'loading-older-messages';
                            loadingDiv.innerHTML = `
                                <div class="loading-spinner"></div>
                            `;
                            messagesContainer.insertBefore(loadingDiv, messagesContainer.firstChild);
                            
                            // WebSocket으로 이전 메시지 요청
                            if (websocket && websocket.readyState === WebSocket.OPEN) {
                                websocket.send(JSON.stringify({
                                    type: 'load_older_messages',
                                    before_timestamp: oldestMessage.timestamp
                                }));
                            }
                        }
                    }
                }
            }, 150); // 150ms 디바운싱
        }
    
        // 메시지 전송 (WebSocket 사용)
        async function sendMessage() {
            const input = document.getElementById('message-input');
            const content = input.value.trim();
            
            if (!content || !currentChannelName || !websocket || websocket.readyState !== WebSocket.OPEN) {
                if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                    showAlert('채팅 서버에 연결되지 않았습니다. 잠시 후 다시 시도해주세요.');
                }
                return;
            }
    
            try {
                // WebSocket으로 메시지 전송
                const messageData = {
                    type: 'message',
                    content: content,
                    message_type: 'text',
                    timestamp: new Date().toISOString()
                };
                
                websocket.send(JSON.stringify(messageData));
                
                input.value = '';
                input.style.height = 'auto';
                updateSendButton();
                
                // 메시지 전송 후 항상 스크롤을 맨 아래로 이동
                setTimeout(() => {
                    const messagesContainer = document.getElementById('chat-messages');
                    if (messagesContainer) {
                        scrollToBottom(messagesContainer, 'smooth');
                        shouldAutoScroll = true; // 전송 후 자동 스크롤 활성화
                    }
                }, 100);
                
            } catch (error) {
                console.error('메시지 전송 오류:', error);
                showAlert('메시지 전송에 실패했습니다.');
            }
        }
    
        // 파일 렌더링
        function renderFiles() {
            const filesContainer = document.getElementById('files-list');
            const files = globalData.files[currentChannelName] || [];
            
            if (files.length === 0) {
                filesContainer.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">📁</div>
                        <div class="empty-title">아직 업로드된 파일이 없습니다</div>
                        <div class="empty-description">파일을 업로드하여 팀원들과 공유해보세요!</div>
                    </div>
                `;
                return;
            }
    
            filesContainer.innerHTML = files.map(file => {
                const uploadTime = new Date(file.uploaded_at).toLocaleString('ko-KR');
                
                return `
                    <div class="file-item">
                        <div class="file-icon">📄</div>
                        <div class="file-info">
                            <div class="file-name">${file.filename}</div>
                            <div class="file-meta">업로드: ${file.uploaded_by} • ${uploadTime} • ${file.file_size}</div>
                        </div>
                        <div class="file-actions">
                            <button class="file-action-btn" onclick="downloadFile('${file.filename}')" title="다운로드">📥</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
    
        // 파일 다운로드
        function downloadFile(filename) {
            // 실제 구현에서는 서버에서 파일 다운로드 URL을 받아와야 함
            showAlert(`파일 다운로드: ${filename}`);
        }
    
        // 메시지 입력 관련
        function updateSendButton() {
            const sendBtn = document.getElementById('send-btn');
            const hasText = document.getElementById('message-input').value.trim().length > 0;
            const isConnected = websocket && websocket.readyState === WebSocket.OPEN;
            sendBtn.disabled = !hasText || !isConnected;
        }
    
        // 역할 목록 로드
        async function loadRoles() {
            try {
                const roles = await apiCall('/workspaces/roles');
                const roleSelect = document.getElementById('min-role');
                
                // 기존 옵션 제거 (첫 번째 "모든 직급" 옵션 제외)
                while (roleSelect.children.length > 1) {
                    roleSelect.removeChild(roleSelect.lastChild);
                }
                
                // 역할 목록 추가
                roles.forEach(role => {
                    const option = document.createElement('option');
                    option.value = role.name;
                    option.textContent = `${role.name} 이상`;
                    roleSelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('역할 목록 로딩 실패:', error);
                // 에러 시 기본 역할 목록 사용
                const roleSelect = document.getElementById('min-role');
                const defaultRoles = ['사원', '대리', '과장', '팀장', '부장', '이사'];
                
                defaultRoles.forEach(roleName => {
                    const option = document.createElement('option');
                    option.value = roleName;
                    option.textContent = `${roleName} 이상`;
                    roleSelect.appendChild(option);
                });
            }
        }

        // 파일 업로드 관련
        function triggerFileUpload() {
            document.getElementById('file-input').click();
        }
    
        function attachFile() {
            triggerFileUpload();
        }

        // 선택된 파일들
        let selectedFiles = [];

        // 파일 업로드 처리
        document.getElementById('file-input').addEventListener('change', function(event) {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                selectedFiles = files;
                showUploadOptions();
            }
        });

        // 업로드 옵션 표시
        function showUploadOptions() {
            const uploadOptions = document.getElementById('upload-options');
            uploadOptions.style.display = 'block';
            uploadOptions.scrollIntoView({ behavior: 'smooth' });
        }

        // 파일 업로드 함수
        async function uploadFile(file) {
            const minRole = document.getElementById('min-role').value;
            const validFrom = document.getElementById('valid-from').value;
            const validTo = document.getElementById('valid-to').value;

            const formData = new FormData();
            formData.append('file', file);
            if (minRole) formData.append('min_role_name', minRole);
            if (validFrom) formData.append('valid_from', validFrom);
            if (validTo) formData.append('valid_to', validTo);

            const token = localStorage.getItem('jwt_token') || localStorage.getItem('access_token');
            const workspaceName = localStorage.getItem('current_workspace_name');
            const response = await fetch(`${API_BASE_URL}/channels/${currentChannelName}/files?workspace_name=${encodeURIComponent(workspaceName)}`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`
                },
                body: formData
            });

            if (!response.ok) {
                throw new Error(`파일 업로드 실패: ${response.status}`);
            }

            const result = await response.json();
            
            if (!globalData.files[currentChannelName]) {
                globalData.files[currentChannelName] = [];
            }
            globalData.files[currentChannelName].push(result);
            renderFiles();
            updateChannelContent();
        }

        // 선택된 파일들 업로드
        async function handleFileUpload() {
            if (selectedFiles.length === 0) return;

            try {
                for (const file of selectedFiles) {
                    await uploadFile(file);
                }
                
                // 업로드 완료 후 초기화
                selectedFiles = [];
                document.getElementById('upload-options').style.display = 'none';
                document.getElementById('file-input').value = '';
                resetUploadForm();
                
            } catch (error) {
                console.error('파일 업로드 실패:', error);
                showAlert(`파일 업로드에 실패했습니다: ${error.message}`);
            }
        }

        // 업로드 폼 초기화
        function resetUploadForm() {
            document.getElementById('min-role').value = '';
            document.getElementById('valid-from').value = '';
            document.getElementById('valid-to').value = '';
        }
    
        // 파일 크기 포맷팅
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    
        // 드래그 앤 드롭 처리
        function setupDragAndDrop() {
            const uploadArea = document.getElementById('upload-area');
            const filesContent = document.querySelector('.files-content');
    
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
                filesContent.addEventListener(eventName, preventDefaults, false);
            });
    
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
    
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, highlight, false);
            });
    
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, unhighlight, false);
            });
    
            function highlight(e) {
                uploadArea.classList.add('drag-over');
            }
    
            function unhighlight(e) {
                uploadArea.classList.remove('drag-over');
            }
    
            uploadArea.addEventListener('drop', handleDrop, false);
    
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                handleFiles(files);
            }
    
            function handleFiles(files) {
                const fileInput = document.getElementById('file-input');
                fileInput.files = files;
                fileInput.dispatchEvent(new Event('change'));
            }
        }
    
        // 기타 기능들
        function addEmoji() {
            const input = document.getElementById('message-input');
            const emojis = ['😊', '👍', '❤️', '🎉', '💯', '🔥', '✨', '🚀', '👏', '💪'];
            const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];
            
            const cursorPos = input.selectionStart;
            const textBefore = input.value.substring(0, cursorPos);
            const textAfter = input.value.substring(cursorPos);
            
            input.value = textBefore + randomEmoji + textAfter;
            input.focus();
            input.setSelectionRange(cursorPos + 2, cursorPos + 2);
            updateSendButton();
        }
    
        function mentionUser() {
            const input = document.getElementById('message-input');
            const members = globalData.teamMembers || [];
            
            if (members.length === 0) {
                showAlert('멘션할 수 있는 팀원이 없습니다.');
                return;
            }
    
            // 간단한 멘션 구현
            const randomMember = members[Math.floor(Math.random() * members.length)];
            const mention = `@${randomMember.user_email.split('@')[0]} `;
            
            const cursorPos = input.selectionStart;
            const textBefore = input.value.substring(0, cursorPos);
            const textAfter = input.value.substring(cursorPos);
            
            input.value = textBefore + mention + textAfter;
            input.focus();
            input.setSelectionRange(cursorPos + mention.length, cursorPos + mention.length);
            updateSendButton();
        }
    
        function voiceMessage() {
            showAlert('음성 메시지 기능은 개발 중입니다.');
        }
    
        function closeNewChannelModal() {
            document.getElementById('new-channel-modal').style.display = 'none';
        }
    
        // 키보드 단축키
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Ctrl+K: 빠른 채널 검색
                if (e.ctrlKey && e.key === 'k') {
                    e.preventDefault();
                    showAlert('빠른 채널 검색 기능은 개발 중입니다.');
                }
                
                // Ctrl+/: 단축키 도움말
                if (e.ctrlKey && e.key === '/') {
                    e.preventDefault();
                    showKeyboardShortcuts();
                }
            });
        }
    
        function showKeyboardShortcuts() {
            showAlert(`
    ⌨️ 키보드 단축키
    
    💬 메시지
    • Enter: 메시지 전송
    • Shift+Enter: 줄바꿈
    
    🔍 탐색
    • Ctrl+K: 빠른 채널 검색
    • ↑/↓: 채널 목록 탐색
    
    ⚙️ 기타
    • Ctrl+/: 단축키 도움말
    • F5: 페이지 새로고침
            `);
        }
    
        // URL 파라미터 처리 (새 채널 알림 등)
        function handleUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const newChannel = urlParams.get('new_channel');
            
            if (newChannel) {
                document.getElementById('new-channel-message').textContent = 
                    `'${newChannel}' 채널이 성공적으로 생성되었습니다!`;
                document.getElementById('new-channel-modal').style.display = 'flex';
                
                // URL에서 파라미터 제거
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }
    
        // 자동 저장 기능 (메시지 임시 저장)
        function setupAutoSave() {
            const messageInput = document.getElementById('message-input');
            const STORAGE_KEY = 'draft_message_';
            
            // 메시지 임시 저장
            messageInput.addEventListener('input', function() {
                if (currentChannelName) {
                    localStorage.setItem(STORAGE_KEY + currentChannelName, this.value);
                }
            });
            
            // 채널 변경 시 임시 저장된 메시지 복원
            function restoreDraftMessage() {
                if (currentChannelName) {
                    const draft = localStorage.getItem(STORAGE_KEY + currentChannelName);
                    if (draft) {
                        messageInput.value = draft;
                        updateSendButton();
                    }
                }
            }
            
            // 메시지 전송 후 임시 저장 삭제
            const originalSendMessage = sendMessage;
            window.sendMessage = async function() {
                await originalSendMessage();
                if (currentChannelName) {
                    localStorage.removeItem(STORAGE_KEY + currentChannelName);
                }
            };
            
            return restoreDraftMessage;
        }
    
        // 페이지 초기화
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🌊 워크스페이스 메인 페이지 로딩 중...');
            
            document.getElementById('loading-overlay').style.display = 'flex';
            
            // 기능 초기화
            const restoreDraftMessage = setupAutoSave();
            setupDragAndDrop();
            setupKeyboardShortcuts();
            handleUrlParameters();
            
            // 워크스페이스 초기화
            initializeWorkspace().then(() => {
                restoreDraftMessage();
                
                // 역할 목록 로드
                loadRoles();
                
                // 날짜 입력 기본값 설정
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('valid-from').min = today;
                document.getElementById('valid-to').min = today;

                // 종료일은 시작일 이후로 제한
                document.getElementById('valid-from').addEventListener('change', function() {
                    document.getElementById('valid-to').min = this.value;
                });

                // 업로드 버튼 이벤트 리스너
                document.getElementById('upload-submit-btn').addEventListener('click', handleFileUpload);
            });
            
            updateSendButton();
            
            // 메시지 입력 이벤트 리스너
            const messageInput = document.getElementById('message-input');
            messageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                updateSendButton();
            });
    
            messageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            // 주기적으로 연결 상태 확인 및 WebSocket 상태 모니터링 (최적화)
            setInterval(() => {
                updateSendButton(); // WebSocket 상태에 따라 전송 버튼 업데이트
                
                // 연결이 끊어진 경우에만 재연결 시도 (더 정확한 체크)
                if (currentChannelName && 
                    (!websocket || websocket.readyState === WebSocket.CLOSED) &&
                    reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    
                    updateConnectionStatus('offline');
                    attemptReconnect();
                }
            }, 15000); // 15초로 증가 (더 긴 간격)
        });
    
        // 페이지 언로드 시 WebSocket 연결 해제 (최적화)
        window.addEventListener('beforeunload', function() {
            if (websocket && websocket.readyState !== WebSocket.CLOSED) {
                try {
                    websocket.close(1000, 'Page unload');
                } catch (e) {
                    console.log('페이지 언로드 시 WebSocket 닫기 실패:', e);
                }
            }
        });

        // 페이지 가시성 변경 시 WebSocket 연결 관리 (최적화)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // 페이지가 숨겨질 때 WebSocket 연결 안전하게 종료
                if (websocket && websocket.readyState !== WebSocket.CLOSED) {
                    try {
                        websocket.close(1000, 'Page hidden');
                        websocket = null;
                    } catch (e) {
                        console.log('페이지 숨김 시 WebSocket 닫기 실패:', e);
                    }
                }
            } else {
                // 페이지가 다시 보일 때 WebSocket 재연결 (개선된 로직)
                if (currentChannelName && (!websocket || websocket.readyState === WebSocket.CLOSED)) {
                    setTimeout(() => {
                        connectWebSocket();
                    }, 500); // 500ms로 단축
                }
            }
        });
    </script>
</body>
</html>

